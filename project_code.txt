=== ./Countries.xcodeproj/xcuserdata/sharapov0140.xcuserdatad/xcschemes/xcschememanagement.plist ===
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>Countries.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
	</dict>
</dict>
</plist>
=== ./Countries.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist ===
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>
=== ./CountriesUITests/CountriesUITests.swift ===
//
//  CountriesUITests.swift
//  CountriesUITests
//
//  Created by Sharapov on 4/15/25.
//

import XCTest

final class CountriesUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    func testLaunchPerformance() throws {
        if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *) {
            // This measures how long it takes to launch your application.
            measure(metrics: [XCTApplicationLaunchMetric()]) {
                XCUIApplication().launch()
            }
        }
    }
}
=== ./CountriesUITests/CountriesUITestsLaunchTests.swift ===
//
//  CountriesUITestsLaunchTests.swift
//  CountriesUITests
//
//  Created by Sharapov on 4/15/25.
//

import XCTest

final class CountriesUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
=== ./Countries/ViewController.swift ===
//
//  ViewController.swift
//  Countries
//
//  Created by Sharapov on 4/15/25.
//

import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }


}

=== ./Countries/ViewModels/CountriesViewModel.swift ===
//
//  CountriesViewModel.swift
//  Countries
//
//  Created by Sharapov on 4/15/25.
//

import Foundation

protocol CountriesViewModelDelegate: AnyObject {
    func didUpdateCountries(_ countries: [Country])
    func didFailToLoadCountries(error: Error?)
}

/// Simple MVVM approach: fetch data from service, store it, and filter it.
class CountriesViewModel {
    weak var delegate: CountriesViewModelDelegate?

    private let service = CountriesService()

    // Keep all countries plus a filtered version
    private var allCountries: [Country] = []
    private(set) var filteredCountries: [Country] = []

    func loadCountries() {
        service.fetchCountries { [weak self] fetchedList in
            DispatchQueue.main.async {
                guard let self = self else { return }
                self.allCountries = fetchedList
                self.filteredCountries = fetchedList
                if fetchedList.isEmpty {
                    self.delegate?.didFailToLoadCountries(error: nil)
                } else {
                    self.delegate?.didUpdateCountries(fetchedList)
                }
            }
        }
    }

    func filter(by query: String) {
        if query.isEmpty {
            filteredCountries = allCountries
        } else {
            let lower = query.lowercased()
            filteredCountries = allCountries.filter {
                $0.name.lowercased().contains(lower) ||
                $0.capital.lowercased().contains(lower)
            }
        }
        delegate?.didUpdateCountries(filteredCountries)
    }
}
=== ./Countries/Models/Country.swift ===
//
//  Country.swift
//  Countries
//
//  Created by Sharapov on 4/15/25.
//

import Foundation


struct Country: Decodable {
    let name: String
    let region: String
    let code: String
    let capital: String
}



//struct Country: Decodable {
//    let name: String
//    let region: String
//    let code: String
//    let capital: String
//    
//    enum CodingKeys: String, CodingKey {
//        case name, region, code, capital
//    }
//    
//    init(from decoder: Decoder) throws {
//        let container = try decoder.container(keyedBy: CodingKeys.self)
//        name = try container.decode(String.self, forKey: .name)
//        region = try container.decode(String.self, forKey: .region)
//        code = try container.decode(String.self, forKey: .code)
//        // If "capital" might be null or missing, decode as String? and fallback:
//        capital = try container.decodeIfPresent(String.self, forKey: .capital) ?? "Unknown"
//    }
//}

=== ./Countries/AppDelegate.swift ===
//
//  AppDelegate.swift
//  Countries
//
//  Created by Sharapov on 4/15/25.
//

import UIKit
import CoreData

@main
class AppDelegate: UIResponder, UIApplicationDelegate {



    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }

    // MARK: - Core Data stack

    lazy var persistentContainer: NSPersistentContainer = {
        /*
         The persistent container for the application. This implementation
         creates and returns a container, having loaded the store for the
         application to it. This property is optional since there are legitimate
         error conditions that could cause the creation of the store to fail.
        */
        let container = NSPersistentContainer(name: "Countries")
        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
            if let error = error as NSError? {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                 
                /*
                 Typical reasons for an error here include:
                 * The parent directory does not exist, cannot be created, or disallows writing.
                 * The persistent store is not accessible, due to permissions or data protection when the device is locked.
                 * The device is out of space.
                 * The store could not be migrated to the current model version.
                 Check the error message to determine what the actual problem was.
                 */
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        })
        return container
    }()

    // MARK: - Core Data Saving support

    func saveContext () {
        let context = persistentContainer.viewContext
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                let nserror = error as NSError
                fatalError("Unresolved error \(nserror), \(nserror.userInfo)")
            }
        }
    }

}

=== ./Countries/Views/CountriesViewController.swift ===
import UIKit

class CountriesViewController: UIViewController {

    private let tableView = UITableView()
    private let searchController = UISearchController(searchResultsController: nil)
    private let viewModel = CountriesViewModel()

    private var countries: [Country] = []

    override func viewDidLoad() {
        super.viewDidLoad()
        title = "Countries"
        view.backgroundColor = .systemBackground

        // Setup Search
        navigationItem.searchController = searchController
        searchController.obscuresBackgroundDuringPresentation = false
        searchController.searchResultsUpdater = self
        navigationItem.hidesSearchBarWhenScrolling = false

        // Table
        tableView.dataSource = self
        tableView.delegate = self

        // IMPORTANT: Use the same reuse identifier "CountryCell"
        tableView.register(CountryCell.self, forCellReuseIdentifier: "CountryCell")

        view.addSubview(tableView)
        tableView.fillSuperview() // Using your anchor extension

        // ViewModel
        viewModel.delegate = self
        viewModel.loadCountries()
    }
}

// MARK: - CountriesViewModelDelegate
extension CountriesViewController: CountriesViewModelDelegate {
    func didUpdateCountries(_ countries: [Country]) {
        // Quick debug check
        print("didUpdateCountries, count = \(countries.count)")
        self.countries = countries
        tableView.reloadData()
    }

    func didFailToLoadCountries(error: Error?) {
        let alert = UIAlertController(title: "Error",
                                      message: "Failed to load countries.",
                                      preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "OK", style: .default))
        present(alert, animated: true)
    }
}

// MARK: - UISearchResultsUpdating
extension CountriesViewController: UISearchResultsUpdating {
    func updateSearchResults(for searchController: UISearchController) {
        let text = searchController.searchBar.text ?? ""
        viewModel.filter(by: text)
    }
}

// MARK: - UITableViewDataSource, UITableViewDelegate
extension CountriesViewController: UITableViewDataSource, UITableViewDelegate {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        print("numberOfRowsInSection => \(countries.count)")
        return countries.count
    }

    func tableView(_ tableView: UITableView,
                   cellForRowAt indexPath: IndexPath) -> UITableViewCell {

        guard let cell = tableView.dequeueReusableCell(
            withIdentifier: "CountryCell", for: indexPath
        ) as? CountryCell else {
            return UITableViewCell()
        }

        let country = countries[indexPath.row]
        cell.configure(
            name: country.name,
            region: country.region,
            code: country.code,
            capital: country.capital
        )
        return cell
    }
}
=== ./Countries/Views/CountryCell.swift ===
import UIKit

final class CountryCell: UITableViewCell {

    private let nameRegionLabel = UILabel()
    private let codeLabel = UILabel()
    private let capitalLabel = UILabel()

    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)

        // 1) Subviews
        nameRegionLabel.translatesAutoresizingMaskIntoConstraints = false
        codeLabel.translatesAutoresizingMaskIntoConstraints = false
        capitalLabel.translatesAutoresizingMaskIntoConstraints = false

        contentView.addSubview(nameRegionLabel)
        contentView.addSubview(codeLabel)
        contentView.addSubview(capitalLabel)

        // 2) Label configurations
        nameRegionLabel.numberOfLines = 0  // allow wrapping for longer name+region
        codeLabel.numberOfLines = 1
        capitalLabel.numberOfLines = 0     // or 1 if you prefer

        // For dynamic type
        nameRegionLabel.adjustsFontForContentSizeCategory = true
        codeLabel.adjustsFontForContentSizeCategory = true
        capitalLabel.adjustsFontForContentSizeCategory = true

        // Example fonts
        nameRegionLabel.font = UIFont.preferredFont(forTextStyle: .body)
        codeLabel.font = UIFont.preferredFont(forTextStyle: .body)
        codeLabel.textAlignment = .right
        capitalLabel.font = UIFont.preferredFont(forTextStyle: .subheadline)
        capitalLabel.textColor = .secondaryLabel

        // 3) Constraints

        // First, set codeLabel's compression resistance priority *outside* the array
        codeLabel.setContentCompressionResistancePriority(.required, for: .horizontal)

        NSLayoutConstraint.activate([
            // A) nameRegionLabel pinned top-left
            nameRegionLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 8),
            nameRegionLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 16),
            // Let nameRegion extend up to codeLabel (lessThanOrEqual)
            nameRegionLabel.trailingAnchor.constraint(lessThanOrEqualTo: codeLabel.leadingAnchor, constant: -8),

            // B) codeLabel pinned top-right
            codeLabel.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 8),
            codeLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -16),

            // C) capitalLabel pinned below nameRegionLabel (for however many lines nameRegionLabel used)
            capitalLabel.topAnchor.constraint(equalTo: nameRegionLabel.bottomAnchor, constant: 8),
            capitalLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 16),
            capitalLabel.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -16),
            capitalLabel.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -8)
        ])
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    // Called from cellForRowAt
    func configure(name: String, region: String, code: String, capital: String) {
        nameRegionLabel.text = "\(name), \(region)"
        codeLabel.text = code
        capitalLabel.text = capital
    }
}
=== ./Countries/Helper/UIViewLayout.swift ===
//
//  UIViewLayout.swift
//  Countries
//
//  Created by Sharapov on 4/15/25.
//


import UIKit


extension UIView {
    
    @discardableResult
    func anchor(top: NSLayoutYAxisAnchor?, leading: NSLayoutXAxisAnchor?, bottom: NSLayoutYAxisAnchor?, trailing: NSLayoutXAxisAnchor?, padding: UIEdgeInsets = .zero, size: CGSize = .zero) -> AnchoredConstraints {
        
        translatesAutoresizingMaskIntoConstraints = false
        var anchoredConstraints = AnchoredConstraints()
        
        if let top = top {
            anchoredConstraints.top = topAnchor.constraint(equalTo: top, constant: padding.top)
        }
        
        if let leading = leading {
            anchoredConstraints.leading = leadingAnchor.constraint(equalTo: leading, constant: padding.left)
        }
        
        if let bottom = bottom {
            anchoredConstraints.bottom = bottomAnchor.constraint(equalTo: bottom, constant: -padding.bottom)
        }
        
        if let trailing = trailing {
            anchoredConstraints.trailing = trailingAnchor.constraint(equalTo: trailing, constant: -padding.right)
        }
        
        if size.width != 0 {
            anchoredConstraints.width = widthAnchor.constraint(equalToConstant: size.width)
        }
        
        if size.height != 0 {
            anchoredConstraints.height = heightAnchor.constraint(equalToConstant: size.height)
        }
        
        [anchoredConstraints.top, anchoredConstraints.leading, anchoredConstraints.bottom, anchoredConstraints.trailing, anchoredConstraints.width, anchoredConstraints.height].forEach{ $0?.isActive = true }
        
        return anchoredConstraints
    }
    
    func fillSuperview(padding: UIEdgeInsets = .zero) {
        translatesAutoresizingMaskIntoConstraints = false
        if let superviewTopAnchor = superview?.topAnchor {
            topAnchor.constraint(equalTo: superviewTopAnchor, constant: padding.top).isActive = true
        }
        
        if let superviewBottomAnchor = superview?.bottomAnchor {
            bottomAnchor.constraint(equalTo: superviewBottomAnchor, constant: -padding.bottom).isActive = true
        }
        
        if let superviewLeadingAnchor = superview?.leadingAnchor {
            leadingAnchor.constraint(equalTo: superviewLeadingAnchor, constant: padding.left).isActive = true
        }
        
        if let superviewTrailingAnchor = superview?.trailingAnchor {
            trailingAnchor.constraint(equalTo: superviewTrailingAnchor, constant: -padding.right).isActive = true
        }
    }
    
    func centerInSuperview(size: CGSize = .zero) {
        translatesAutoresizingMaskIntoConstraints = false
        if let superviewCenterXAnchor = superview?.centerXAnchor {
            centerXAnchor.constraint(equalTo: superviewCenterXAnchor).isActive = true
        }
        
        if let superviewCenterYAnchor = superview?.centerYAnchor {
            centerYAnchor.constraint(equalTo: superviewCenterYAnchor).isActive = true
        }
        
        if size.width != 0 {
            widthAnchor.constraint(equalToConstant: size.width).isActive = true
        }
        
        if size.height != 0 {
            heightAnchor.constraint(equalToConstant: size.height).isActive = true
        }
    }
    
    func centerXInSuperview() {
        translatesAutoresizingMaskIntoConstraints = false
        if let superViewCenterXAnchor = superview?.centerXAnchor {
            centerXAnchor.constraint(equalTo: superViewCenterXAnchor).isActive = true
        }
    }
    
    func centerYInSuperview() {
        translatesAutoresizingMaskIntoConstraints = false
        if let centerY = superview?.centerYAnchor {
            centerYAnchor.constraint(equalTo: centerY).isActive = true
        }
    }
    
    func constrainWidth(constant: CGFloat) {
        translatesAutoresizingMaskIntoConstraints = false
        widthAnchor.constraint(equalToConstant: constant).isActive = true
    }
    
    func constrainHeight(constant: CGFloat) {
        translatesAutoresizingMaskIntoConstraints = false
        heightAnchor.constraint(equalToConstant: constant).isActive = true
    }
}

struct AnchoredConstraints {
    var top, leading, bottom, trailing, width, height: NSLayoutConstraint?
}

=== ./Countries/Info.plist ===
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
		<key>UISceneConfigurations</key>
		<dict>
			<key>UIWindowSceneSessionRoleApplication</key>
			<array>
				<dict>
					<key>UISceneConfigurationName</key>
					<string>Default Configuration</string>
					<key>UISceneDelegateClassName</key>
					<string>$(PRODUCT_MODULE_NAME).SceneDelegate</string>
					<key>UISceneStoryboardFile</key>
					<string>Main</string>
				</dict>
			</array>
		</dict>
	</dict>
</dict>
</plist>
=== ./Countries/Services/CountriesService.swift ===
//
//  CountriesService.swift
//  Countries
//
//  Created by Sharapov on 4/15/25.
//

import Foundation

class CountriesService {
    // Hardcode the JSON URL from the assignment instructions:
    private let countriesURL = URL(string:
     "https://gist.githubusercontent.com/peymano-wmt/32dcb892b06648910ddd40406e37fdab/raw/db25946fd77c5873b0303b858e861ce724e0dcd0/countries.json"
    )!

    func fetchCountries(completion: @escaping ([Country]) -> Void) {
        let task = URLSession.shared.dataTask(with: countriesURL) { data, _, error in
            guard let data = data, error == nil else {
                completion([])
                return
            }
            do {
                // It's an array of Country objects
                // Possibly the top-level is `{"[": <some array>}`,
                // but from the snippet it looks like it’s a top-level array.
                let decoded = try JSONDecoder().decode([Country].self, from: data)
                completion(decoded)
            } catch {
                completion([])
            }
        }
        task.resume()
    }
}

=== ./Countries/SceneDelegate.swift ===
//
//  SceneDelegate.swift
//  Countries
//
//  Created by Sharapov on 4/15/25.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
//        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
//        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
//        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
//        guard let _ = (scene as? UIWindowScene) else { return }
        guard let windowScene = (scene as? UIWindowScene) else { return }

        let window = UIWindow(windowScene: windowScene)
        let navController = UINavigationController(rootViewController: CountriesViewController())
        window.rootViewController = navController
        self.window = window
        window.makeKeyAndVisible()
    }

    func sceneDidDisconnect(_ scene: UIScene) {
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        // Called when the scene has moved from an inactive state to an active state.
        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        // Called as the scene transitions from the background to the foreground.
        // Use this method to undo the changes made on entering the background.
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this method to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.

        // Save changes in the application's managed object context when the application transitions to the background.
        (UIApplication.shared.delegate as? AppDelegate)?.saveContext()
    }


}

=== ./CountriesTests/CountriesTests.swift ===
//
//  CountriesTests.swift
//  CountriesTests
//
//  Created by Sharapov on 4/15/25.
//

import XCTest
@testable import Countries

final class CountriesTests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    func testExample() throws {
        // This is an example of a functional test case.
        // Use XCTAssert and related functions to verify your tests produce the correct results.
        // Any test you write for XCTest can be annotated as throws and async.
        // Mark your test throws to produce an unexpected failure when your test encounters an uncaught error.
        // Mark your test async to allow awaiting for asynchronous code to complete. Check the results with assertions afterwards.
    }

    func testPerformanceExample() throws {
        // This is an example of a performance test case.
        self.measure {
            // Put the code you want to measure the time of here.
        }
    }

}
